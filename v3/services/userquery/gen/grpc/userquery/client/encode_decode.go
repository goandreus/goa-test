// Code generated by goa v3.0.9, DO NOT EDIT.
//
// userquery gRPC client encoders and decoders
//
// Command:
// $ goa gen gitlab.com/wiserskills/v3/services/userquery/design

package client

import (
	"context"

	userquerypb "gitlab.com/wiserskills/v3/services/userquery/gen/grpc/userquery/pb"
	userquery "gitlab.com/wiserskills/v3/services/userquery/gen/userquery"
	userqueryviews "gitlab.com/wiserskills/v3/services/userquery/gen/userquery/views"
	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildSignInFunc builds the remote method to invoke for "userquery" service
// "SignIn" endpoint.
func BuildSignInFunc(grpccli userquerypb.UserqueryClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SignIn(ctx, reqpb.(*userquerypb.SignInRequest), opts...)
		}
		return grpccli.SignIn(ctx, &userquerypb.SignInRequest{}, opts...)
	}
}

// EncodeSignInRequest encodes requests sent to userquery SignIn endpoint.
func EncodeSignInRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userquery.SignInPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "SignIn", "*userquery.SignInPayload", v)
	}
	(*md).Append("username", payload.Username)
	(*md).Append("password", payload.Password)
	if payload.Key != nil {
		(*md).Append("authorization", *payload.Key)
	}
	return NewSignInRequest(payload), nil
}

// DecodeSignInResponse decodes responses from the userquery SignIn endpoint.
func DecodeSignInResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*userquerypb.SignInResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "SignIn", "*userquerypb.SignInResponse", v)
	}
	res := NewSignInResult(message)
	return res, nil
}

// BuildSignOutFunc builds the remote method to invoke for "userquery" service
// "SignOut" endpoint.
func BuildSignOutFunc(grpccli userquerypb.UserqueryClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.SignOut(ctx, reqpb.(*userquerypb.SignOutRequest), opts...)
		}
		return grpccli.SignOut(ctx, &userquerypb.SignOutRequest{}, opts...)
	}
}

// EncodeSignOutRequest encodes requests sent to userquery SignOut endpoint.
func EncodeSignOutRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userquery.TokenPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "SignOut", "*userquery.TokenPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	(*md).Append("authorization", payload.Key)
	return NewSignOutRequest(payload), nil
}

// BuildGetAllSessionsFunc builds the remote method to invoke for "userquery"
// service "GetAllSessions" endpoint.
func BuildGetAllSessionsFunc(grpccli userquerypb.UserqueryClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.GetAllSessions(ctx, reqpb.(*userquerypb.GetAllSessionsRequest), opts...)
		}
		return grpccli.GetAllSessions(ctx, &userquerypb.GetAllSessionsRequest{}, opts...)
	}
}

// EncodeGetAllSessionsRequest encodes requests sent to userquery
// GetAllSessions endpoint.
func EncodeGetAllSessionsRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userquery.AllSessionsPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "GetAllSessions", "*userquery.AllSessionsPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	(*md).Append("authorization", payload.Key)
	return NewGetAllSessionsRequest(payload), nil
}

// DecodeGetAllSessionsResponse decodes responses from the userquery
// GetAllSessions endpoint.
func DecodeGetAllSessionsResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*userquerypb.SessionCollection)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "GetAllSessions", "*userquerypb.SessionCollection", v)
	}
	res := NewGetAllSessionsResult(message)
	vres := userqueryviews.SessionCollection{Projected: res, View: view}
	if err := userqueryviews.ValidateSessionCollection(vres); err != nil {
		return nil, err
	}
	return userquery.NewSessionCollection(vres), nil
}

// BuildGetIDPURLFunc builds the remote method to invoke for "userquery"
// service "GetIDPURL" endpoint.
func BuildGetIDPURLFunc(grpccli userquerypb.UserqueryClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.GetIDPURL(ctx, reqpb.(*userquerypb.GetIDPURLRequest), opts...)
		}
		return grpccli.GetIDPURL(ctx, &userquerypb.GetIDPURLRequest{}, opts...)
	}
}

// EncodeGetIDPURLRequest encodes requests sent to userquery GetIDPURL endpoint.
func EncodeGetIDPURLRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userquery.HostPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "GetIDPURL", "*userquery.HostPayload", v)
	}
	(*md).Append("authorization", payload.Key)
	return NewGetIDPURLRequest(payload), nil
}

// DecodeGetIDPURLResponse decodes responses from the userquery GetIDPURL
// endpoint.
func DecodeGetIDPURLResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*userquerypb.GetIDPURLResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "GetIDPURL", "*userquerypb.GetIDPURLResponse", v)
	}
	res := NewGetIDPURLResult(message)
	return res, nil
}

// BuildCheckTokenFunc builds the remote method to invoke for "userquery"
// service "CheckToken" endpoint.
func BuildCheckTokenFunc(grpccli userquerypb.UserqueryClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.CheckToken(ctx, reqpb.(*userquerypb.CheckTokenRequest), opts...)
		}
		return grpccli.CheckToken(ctx, &userquerypb.CheckTokenRequest{}, opts...)
	}
}

// EncodeCheckTokenRequest encodes requests sent to userquery CheckToken
// endpoint.
func EncodeCheckTokenRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userquery.TokenPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "CheckToken", "*userquery.TokenPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	(*md).Append("authorization", payload.Key)
	return NewCheckTokenRequest(payload), nil
}

// BuildGetUsersByIDFunc builds the remote method to invoke for "userquery"
// service "GetUsersByID" endpoint.
func BuildGetUsersByIDFunc(grpccli userquerypb.UserqueryClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.GetUsersByID(ctx, reqpb.(*userquerypb.GetUsersByIDRequest), opts...)
		}
		return grpccli.GetUsersByID(ctx, &userquerypb.GetUsersByIDRequest{}, opts...)
	}
}

// EncodeGetUsersByIDRequest encodes requests sent to userquery GetUsersByID
// endpoint.
func EncodeGetUsersByIDRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userquery.ManyUserIDPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "GetUsersByID", "*userquery.ManyUserIDPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	(*md).Append("authorization", payload.Key)
	return NewGetUsersByIDRequest(payload), nil
}

// DecodeGetUsersByIDResponse decodes responses from the userquery GetUsersByID
// endpoint.
func DecodeGetUsersByIDResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*userquerypb.RegisteredUserCollection)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "GetUsersByID", "*userquerypb.RegisteredUserCollection", v)
	}
	res := NewGetUsersByIDResult(message)
	vres := userqueryviews.RegisteredUserCollection{Projected: res, View: view}
	if err := userqueryviews.ValidateRegisteredUserCollection(vres); err != nil {
		return nil, err
	}
	return userquery.NewRegisteredUserCollection(vres), nil
}
