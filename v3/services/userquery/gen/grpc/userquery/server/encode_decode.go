// Code generated by goa v3.0.9, DO NOT EDIT.
//
// userquery gRPC server encoders and decoders
//
// Command:
// $ goa gen gitlab.com/wiserskills/v3/services/userquery/design

package server

import (
	"context"
	"strings"
	"unicode/utf8"

	userquerypb "gitlab.com/wiserskills/v3/services/userquery/gen/grpc/userquery/pb"
	userquery "gitlab.com/wiserskills/v3/services/userquery/gen/userquery"
	userqueryviews "gitlab.com/wiserskills/v3/services/userquery/gen/userquery/views"
	goagrpc "goa.design/goa/v3/grpc"
	goa "goa.design/goa/v3/pkg"
	"google.golang.org/grpc/metadata"
)

// EncodeSignInResponse encodes responses from the "userquery" service "SignIn"
// endpoint.
func EncodeSignInResponse(ctx context.Context, v interface{}, hdr, trlr *metadata.MD) (interface{}, error) {
	result, ok := v.(*userquery.JWTToken)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "SignIn", "*userquery.JWTToken", v)
	}
	resp := NewSignInResponse(result)
	return resp, nil
}

// DecodeSignInRequest decodes requests sent to "userquery" service "SignIn"
// endpoint.
func DecodeSignInRequest(ctx context.Context, v interface{}, md metadata.MD) (interface{}, error) {
	var (
		username string
		password string
		key      *string
		err      error
	)
	{
		if vals := md.Get("username"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("username", "metadata"))
		} else {
			username = vals[0]
		}
		if vals := md.Get("password"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("password", "metadata"))
		} else {
			password = vals[0]
		}
		if vals := md.Get("authorization"); len(vals) > 0 {
			key = &vals[0]
		}
	}
	if err != nil {
		return nil, err
	}
	var (
		message *userquerypb.SignInRequest
		ok      bool
	)
	{
		if message, ok = v.(*userquerypb.SignInRequest); !ok {
			return nil, goagrpc.ErrInvalidType("userquery", "SignIn", "*userquerypb.SignInRequest", v)
		}
		if err = ValidateSignInRequest(message); err != nil {
			return nil, err
		}
	}
	var payload *userquery.SignInPayload
	{
		payload = NewSignInPayload(message, username, password, key)
		if payload.Key != nil {
			if strings.Contains(*payload.Key, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Key, " ", 2)[1]
				payload.Key = &cred
			}
		}
	}
	return payload, nil
}

// EncodeSignOutResponse encodes responses from the "userquery" service
// "SignOut" endpoint.
func EncodeSignOutResponse(ctx context.Context, v interface{}, hdr, trlr *metadata.MD) (interface{}, error) {
	resp := NewSignOutResponse()
	return resp, nil
}

// DecodeSignOutRequest decodes requests sent to "userquery" service "SignOut"
// endpoint.
func DecodeSignOutRequest(ctx context.Context, v interface{}, md metadata.MD) (interface{}, error) {
	var (
		token string
		key   string
		err   error
	)
	{
		if vals := md.Get("authorization"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
		} else {
			token = vals[0]
		}
		if vals := md.Get("authorization"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
		} else {
			key = vals[0]
		}
	}
	if err != nil {
		return nil, err
	}
	var (
		message *userquerypb.SignOutRequest
		ok      bool
	)
	{
		if message, ok = v.(*userquerypb.SignOutRequest); !ok {
			return nil, goagrpc.ErrInvalidType("userquery", "SignOut", "*userquerypb.SignOutRequest", v)
		}
		if err = ValidateSignOutRequest(message); err != nil {
			return nil, err
		}
	}
	var payload *userquery.TokenPayload
	{
		payload = NewSignOutPayload(message, token, key)
		if strings.Contains(payload.Token, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Token, " ", 2)[1]
			payload.Token = cred
		}
		if strings.Contains(payload.Key, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Key, " ", 2)[1]
			payload.Key = cred
		}
	}
	return payload, nil
}

// EncodeGetAllSessionsResponse encodes responses from the "userquery" service
// "GetAllSessions" endpoint.
func EncodeGetAllSessionsResponse(ctx context.Context, v interface{}, hdr, trlr *metadata.MD) (interface{}, error) {
	vres, ok := v.(userqueryviews.SessionCollection)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "GetAllSessions", "userqueryviews.SessionCollection", v)
	}
	result := vres.Projected
	(*hdr).Append("goa-view", vres.View)
	resp := NewSessionCollection(result)
	return resp, nil
}

// DecodeGetAllSessionsRequest decodes requests sent to "userquery" service
// "GetAllSessions" endpoint.
func DecodeGetAllSessionsRequest(ctx context.Context, v interface{}, md metadata.MD) (interface{}, error) {
	var (
		token string
		key   string
		err   error
	)
	{
		if vals := md.Get("authorization"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
		} else {
			token = vals[0]
		}
		if utf8.RuneCountInString(token) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("token", token, utf8.RuneCountInString(token), 1024, false))
		}
		if vals := md.Get("authorization"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
		} else {
			key = vals[0]
		}
	}
	if err != nil {
		return nil, err
	}
	var (
		message *userquerypb.GetAllSessionsRequest
		ok      bool
	)
	{
		if message, ok = v.(*userquerypb.GetAllSessionsRequest); !ok {
			return nil, goagrpc.ErrInvalidType("userquery", "GetAllSessions", "*userquerypb.GetAllSessionsRequest", v)
		}
		if err = ValidateGetAllSessionsRequest(message); err != nil {
			return nil, err
		}
	}
	var payload *userquery.AllSessionsPayload
	{
		payload = NewGetAllSessionsPayload(message, token, key)
		if strings.Contains(payload.Token, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Token, " ", 2)[1]
			payload.Token = cred
		}
		if strings.Contains(payload.Key, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Key, " ", 2)[1]
			payload.Key = cred
		}
	}
	return payload, nil
}

// EncodeGetIDPURLResponse encodes responses from the "userquery" service
// "GetIDPURL" endpoint.
func EncodeGetIDPURLResponse(ctx context.Context, v interface{}, hdr, trlr *metadata.MD) (interface{}, error) {
	result, ok := v.(*userquery.RedirectResult)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "GetIDPURL", "*userquery.RedirectResult", v)
	}
	resp := NewGetIDPURLResponse(result)
	return resp, nil
}

// DecodeGetIDPURLRequest decodes requests sent to "userquery" service
// "GetIDPURL" endpoint.
func DecodeGetIDPURLRequest(ctx context.Context, v interface{}, md metadata.MD) (interface{}, error) {
	var (
		key string
		err error
	)
	{
		if vals := md.Get("authorization"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
		} else {
			key = vals[0]
		}
	}
	if err != nil {
		return nil, err
	}
	var (
		message *userquerypb.GetIDPURLRequest
		ok      bool
	)
	{
		if message, ok = v.(*userquerypb.GetIDPURLRequest); !ok {
			return nil, goagrpc.ErrInvalidType("userquery", "GetIDPURL", "*userquerypb.GetIDPURLRequest", v)
		}
		if err = ValidateGetIDPURLRequest(message); err != nil {
			return nil, err
		}
	}
	var payload *userquery.HostPayload
	{
		payload = NewGetIDPURLPayload(message, key)
		if strings.Contains(payload.Key, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Key, " ", 2)[1]
			payload.Key = cred
		}
	}
	return payload, nil
}

// EncodeCheckTokenResponse encodes responses from the "userquery" service
// "CheckToken" endpoint.
func EncodeCheckTokenResponse(ctx context.Context, v interface{}, hdr, trlr *metadata.MD) (interface{}, error) {
	resp := NewCheckTokenResponse()
	return resp, nil
}

// DecodeCheckTokenRequest decodes requests sent to "userquery" service
// "CheckToken" endpoint.
func DecodeCheckTokenRequest(ctx context.Context, v interface{}, md metadata.MD) (interface{}, error) {
	var (
		token string
		key   string
		err   error
	)
	{
		if vals := md.Get("authorization"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
		} else {
			token = vals[0]
		}
		if vals := md.Get("authorization"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
		} else {
			key = vals[0]
		}
	}
	if err != nil {
		return nil, err
	}
	var (
		message *userquerypb.CheckTokenRequest
		ok      bool
	)
	{
		if message, ok = v.(*userquerypb.CheckTokenRequest); !ok {
			return nil, goagrpc.ErrInvalidType("userquery", "CheckToken", "*userquerypb.CheckTokenRequest", v)
		}
		if err = ValidateCheckTokenRequest(message); err != nil {
			return nil, err
		}
	}
	var payload *userquery.TokenPayload
	{
		payload = NewCheckTokenPayload(message, token, key)
		if strings.Contains(payload.Token, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Token, " ", 2)[1]
			payload.Token = cred
		}
		if strings.Contains(payload.Key, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Key, " ", 2)[1]
			payload.Key = cred
		}
	}
	return payload, nil
}

// EncodeGetUsersByIDResponse encodes responses from the "userquery" service
// "GetUsersByID" endpoint.
func EncodeGetUsersByIDResponse(ctx context.Context, v interface{}, hdr, trlr *metadata.MD) (interface{}, error) {
	vres, ok := v.(userqueryviews.RegisteredUserCollection)
	if !ok {
		return nil, goagrpc.ErrInvalidType("userquery", "GetUsersByID", "userqueryviews.RegisteredUserCollection", v)
	}
	result := vres.Projected
	(*hdr).Append("goa-view", vres.View)
	resp := NewRegisteredUserCollection(result)
	return resp, nil
}

// DecodeGetUsersByIDRequest decodes requests sent to "userquery" service
// "GetUsersByID" endpoint.
func DecodeGetUsersByIDRequest(ctx context.Context, v interface{}, md metadata.MD) (interface{}, error) {
	var (
		token string
		key   string
		err   error
	)
	{
		if vals := md.Get("authorization"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
		} else {
			token = vals[0]
		}
		if vals := md.Get("authorization"); len(vals) == 0 {
			err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
		} else {
			key = vals[0]
		}
	}
	if err != nil {
		return nil, err
	}
	var (
		message *userquerypb.GetUsersByIDRequest
		ok      bool
	)
	{
		if message, ok = v.(*userquerypb.GetUsersByIDRequest); !ok {
			return nil, goagrpc.ErrInvalidType("userquery", "GetUsersByID", "*userquerypb.GetUsersByIDRequest", v)
		}
		if err = ValidateGetUsersByIDRequest(message); err != nil {
			return nil, err
		}
	}
	var payload *userquery.ManyUserIDPayload
	{
		payload = NewGetUsersByIDPayload(message, token, key)
		if strings.Contains(payload.Token, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Token, " ", 2)[1]
			payload.Token = cred
		}
		if strings.Contains(payload.Key, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Key, " ", 2)[1]
			payload.Key = cred
		}
	}
	return payload, nil
}
