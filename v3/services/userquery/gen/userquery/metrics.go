// Code generated by goa v3.0.9, DO NOT EDIT.
//
// Prometheus Metrics Helper
//
// Command:
// $ goa gen gitlab.com/wiserskills/v3/services/userquery/design

package userquery

import (
	"fmt"
	"strings"
	"sync"

	"github.com/prometheus/client_golang/prometheus"
)

// MetricType represents a possible type of metrics
type MetricType int

const (
	// Counter metric type
	Counter MetricType = 1
	// CounterVector metric type
	CounterVector MetricType = 2
	// Summary metric type
	Summary MetricType = 3
	// SummaryVector metric type
	SummaryVector MetricType = 4
	// Gauge metric type
	Gauge MetricType = 5
	// Histogram metric type
	Histogram MetricType = 6
	// HistogramVector metric type
	HistogramVector MetricType = 7
)

// metric represents a single metric definition
type metric struct {
	Name        string
	Description string
	Type        MetricType
	Inner       interface{}
}

// Metrics represents a collection of metrics
type Metrics struct {
	rm    *sync.RWMutex
	items map[string]*metric
}

func (m *Metrics) Get(name string) *metric {

	var result *metric

	m.rm.RLock()
	result = m.items[name]
	m.rm.RUnlock()

	return result
}

func (m *Metrics) Set(name string, mc *metric) {
	m.rm.Lock()
	m.items[name] = mc
	m.rm.Unlock()
}

func (m *Metrics) IncrCounter(name string) {
	counter := m.GetCounter(name)
	if counter != nil {
		counter.Inc()
	}
}

// NewMetrics creates a new collection of metrics
func NewMetrics() *Metrics {
	return &Metrics{items: make(map[string]*metric), rm: &sync.RWMutex{}}
}

// NewCounter creates a new counter
func (m *Metrics) NewCounter(name string, description string) prometheus.Counter {

	var item prometheus.Counter

	mc := m.Get(name)

	if mc == nil {

		options := prometheus.CounterOpts{
			Name: name,
			Help: description,
		}

		item = prometheus.NewCounter(options)
		prometheus.Register(item)

		mc = &metric{Name: name, Description: description, Type: Counter, Inner: item}

		m.Set(name, mc)

	} else {
		item = mc.Inner.(prometheus.Counter)
	}

	return item
}

// NewCounterVec creates a new counter vector
func (m *Metrics) NewCounterVec(name string, description string, labels []string) *prometheus.CounterVec {

	var item *prometheus.CounterVec

	mc := m.Get(name)

	if mc == nil {

		options := prometheus.CounterOpts{
			Name: name,
			Help: description,
		}

		item = prometheus.NewCounterVec(options, labels)
		prometheus.Register(item)

		mc = &metric{Name: name, Description: description, Type: CounterVector, Inner: item}

		m.Set(name, mc)

	} else {
		item = mc.Inner.(*prometheus.CounterVec)
	}

	return item
}

// NewGauge creates a new gauge
func (m *Metrics) NewGauge(name string, description string) prometheus.Gauge {

	var item prometheus.Gauge

	mc := m.Get(name)

	if mc == nil {

		options := prometheus.GaugeOpts{
			Name: name,
			Help: description,
		}

		item = prometheus.NewGauge(options)
		prometheus.Register(item)

		mc = &metric{Name: name, Description: description, Type: Gauge, Inner: item}

		m.Set(name, mc)

	} else {
		item = mc.Inner.(prometheus.Gauge)
	}

	return item
}

// GetCounter returns the counter with the specified nampe
func (m *Metrics) GetCounter(name string) prometheus.Counter {

	item := m.Get(name)

	if item != nil {

		return item.Inner.(prometheus.Counter)
	}

	return nil
}

// GetCounterVec returns the counter vector with the specified nampe
func (m *Metrics) GetCounterVec(name string) *prometheus.CounterVec {

	item := m.Get(name)

	if item != nil {

		return item.Inner.(*prometheus.CounterVec)
	}

	return nil
}

// GetGauge returns the gauge with the specified nampe
func (m *Metrics) GetGauge(name string) prometheus.Gauge {

	item := m.Get(name)

	if item != nil {

		return item.Inner.(prometheus.Gauge)
	}

	return nil
}

// EndpointStarted is called when an endpoint is just starting
func (m *Metrics) EndpointStarted(endpointName string) prometheus.Gauge {

	nc := fmt.Sprintf("endpoint_%s_total_called", strings.ToLower(endpointName))
	dc := fmt.Sprintf("Total number of calls to the %s endpoint method", endpointName)

	ng := fmt.Sprintf("endpoint_%s_executing", strings.ToLower(endpointName))
	dg := fmt.Sprintf("Counts the number of currently running %s endpoint methods", endpointName)

	// Creating endpoint total calls counter if doesn't exist already
	calls := m.GetCounter(nc)
	if calls == nil {
		calls = m.NewCounter(nc, dc)
	}

	// Creating endpoint executing gauge if doesn't exist already
	executing := m.GetGauge(ng)
	if executing == nil {
		executing = m.NewGauge(ng, dg)
	}

	// We increment the counters
	calls.Inc()
	executing.Inc()
	return executing
}

// EndpointSuccess can be called when a call to an endpoint raised no error
func (m *Metrics) EndpointSuccess(endpointName string) {

	name := fmt.Sprintf("endpoint_%s_total_calls", strings.ToLower(endpointName))
	description := fmt.Sprintf("Total number of calls to %s endpoint", endpointName)
	labels := []string{"code"}

	item := m.Get(name)

	if item != nil {
		item.Inner.(*prometheus.CounterVec).WithLabelValues("200").Add(1)
	} else {
		c := m.NewCounterVec(name, description, labels)
		c.WithLabelValues("200").Add(1)
	}
}

// EndpointFailure can be called when a call to an endpoint raised an error
func (m *Metrics) EndpointFailure(endpointName string, errCode string) {

	name := fmt.Sprintf("endpoint_%s_total_calls", strings.ToLower(endpointName))
	description := fmt.Sprintf("Total number of calls to %s endpoint", endpointName)
	labels := []string{"code"}

	item := m.Get(name)

	if item != nil {
		item.Inner.(*prometheus.CounterVec).WithLabelValues(errCode).Add(1)
	} else {
		c := m.NewCounterVec(name, description, labels)
		c.WithLabelValues(errCode).Add(1)
	}
}
