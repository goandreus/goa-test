// Code generated by goa v3.0.9, DO NOT EDIT.
//
// userquery service
//
// Command:
// $ goa gen gitlab.com/wiserskills/v3/services/userquery/design

package userquery

import (
	"context"

	userqueryviews "gitlab.com/wiserskills/v3/services/userquery/gen/userquery/views"
	goa "goa.design/goa/v3/pkg"
	"goa.design/goa/v3/security"
)

// API service to authenticate users. The service requires an ArangoDB server.
// Data synchronization with other services is done via a shared NATS Streaming
// event bus.
type Service interface {
	// Signs a user in.
	SignIn(context.Context, *SignInPayload) (res *JWTToken, err error)
	// Signs a user out.
	SignOut(context.Context, *TokenPayload) (err error)
	// Returns the currently active sessions.
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "tiny"
	GetAllSessions(context.Context, *AllSessionsPayload) (res SessionCollection, view string, err error)
	// Returns the URL of the IDP to redirect the user to.
	GetIDPURL(context.Context, *HostPayload) (res *RedirectResult, err error)
	// Call back endpoint called by the IDP once the user is authenticated.
	SamlSignIn(context.Context, string) (res *RedirectResult, err error)
	// Checks if the passed token is valid.
	CheckToken(context.Context, *TokenPayload) (err error)
	// Returns the users with the specified ids.
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "tiny"
	GetUsersByID(context.Context, *ManyUserIDPayload) (res RegisteredUserCollection, view string, err error)
	// Health status endpoint.
	Health(context.Context) (res *HealthResult, err error)
}

// Auther defines the authorization functions to be implemented by the service.
type Auther interface {
	// BasicAuth implements the authorization logic for the Basic security scheme.
	BasicAuth(ctx context.Context, user, pass string, schema *security.BasicScheme) (context.Context, error)
	// APIKeyAuth implements the authorization logic for the APIKey security scheme.
	APIKeyAuth(ctx context.Context, key string, schema *security.APIKeyScheme) (context.Context, error)
	// JWTAuth implements the authorization logic for the JWT security scheme.
	JWTAuth(ctx context.Context, token string, schema *security.JWTScheme) (context.Context, error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "userquery"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [11]string{"SignIn", "SignOut", "GetAllSessions", "GetIDPURL", "SamlSignIn", "CheckToken", "GetUsersByID", "health", "metrics", "swagger", "swagger-ui"}

// Credentials used to authenticate and retrieve a JWT token
type SignInPayload struct {
	// API key
	Key *string
	// Username used to perform signin
	Username string
	// Password used to perform signin
	Password string
	// The id of the organization.
	OrgID string
	// The id of the area.
	AreaID string
}

// JWTToken is the result type of the userquery service SignIn method.
type JWTToken struct {
	// JWT token
	Token string
}

// TokenPayload is the payload type of the userquery service SignOut method.
type TokenPayload struct {
	// API key
	Key string
	// JWT used for authentication
	Token string
	// The id of the organization
	OrgID string
	// The id of the area
	AreaID string
}

// AllSessionsPayload is the payload type of the userquery service
// GetAllSessions method.
type AllSessionsPayload struct {
	// API key
	Key string
	// JWT used for authentication
	Token string
	// The id of the organization
	OrgID string
	// The id of the area
	AreaID string
	// View to render.
	View *string
}

// SessionCollection is the result type of the userquery service GetAllSessions
// method.
type SessionCollection []*Session

// HostPayload is the payload type of the userquery service GetIDPURL method.
type HostPayload struct {
	// API key
	Key string
	// The target host.
	Host string
	// The id of the organization
	OrgID string
	// The id of the area
	AreaID string
}

// RedirectResult is the result type of the userquery service GetIDPURL method.
type RedirectResult struct {
	// The url to redirect the caller to.
	Location string
}

// ManyUserIDPayload is the payload type of the userquery service GetUsersByID
// method.
type ManyUserIDPayload struct {
	// API key
	Key string
	// JWT used for authentication
	Token string
	// The id of the organization
	OrgID string
	// The id of the area
	AreaID string
	// The ids of the users to retrieve
	Ids []string
	// The view used for the returned users
	View string
	// defines if only active users must be returned
	ActiveOnly bool
}

// RegisteredUserCollection is the result type of the userquery service
// GetUsersByID method.
type RegisteredUserCollection []*RegisteredUser

// Status information of the service.
type HealthResult struct {
	// The status of the service
	Status string
}

// Session is the type used to represents an application session.
type Session struct {
	// The UUID of the session.
	ID string `json:"id,omitempty"`
	// The id of entity in the document database.
	Key *string `json:"_key,omitempty"`
	// The id of the associated organization.
	OrganizationID string `json:"organizationId,omitempty"`
	// The id of the associated area.
	AreaID string `json:"areaId,omitempty"`
	// The UUID of the user.
	UserID string `json:"userId,omitempty"`
	// The UUID of the token.
	TokenID string `json:"tokenId,omitempty"`
	// The date/time the record was created.
	CreatedAt *string `json:"createdAt,omitempty"`
	// The date/time the record was updated.
	UpdatedAt *string `updatedAt:"uri,omitempty"`
	// The date/time the session will expire.
	ExpiresAt *string `json:"expiresAt,omitempty"`
}

// Represents a registered user.
type RegisteredUser struct {
	// The UUID of the underlying or referenced entity.
	ID string `json:"id,omitempty"`
	// The first name of the user.
	FirstName string `json:"firstName,omitempty"`
	// The last name of the user.
	LastName string `json:"lastName,omitempty" storm:"index"`
	// Defines if the entity is active.
	Active bool `json:"active"`
	// The birth name of the user.
	BirthName string `json:"birthName,omitempty"`
	// The address of the user.
	Address *string `json:"address,omitempty"`
	// The id of the city.
	CityID *string `json:"cityId,omitempty"`
	// The ISO 3166-1 code of the country.
	CountryID *string `json:"countryId,omitempty"`
	// The latitude of the user's address.
	Latitude *float64 `json:"latitude,omitempty"`
	// The longitude of the user's address.
	Longitude *float64 `json:"longitude,omitempty"`
	// The birth date of the user.
	BirthDate *string `json:"birthDate,omitempty"`
	// The gender of the user.
	Gender *string `json:"gender,omitempty"`
	// The ISO code of the user's prefered language.
	LanguageID *string `json:"languageId,omitempty"`
	// The email of the user.
	Email string `json:"email,omitempty"`
	// The login of the user.
	Login string `json:"login,omitempty"`
	// The user mobile phone number.
	Mobile *string `json:"mobile,omitempty"`
	// Defines if this user is a B2C user.
	B2C bool `json:"b2c,omitempty"`
	// The date/time the record was created.
	CreatedAt *string `json:"createdAt,omitempty"`
	// The date/time the record was last updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// The id of organization where the user was created.
	OrganizationID string `json:"organizationId,omitempty"`
	// The list of the user roles.
	Roles []string `json:"roles,omitempty"`
}

// LogLevelInfo is the type used to specify a level of log.
type LogLevelInfo struct {
	// The name of the service
	Service string
	// The id of the service instance
	InstanceID string
	// The required log level. Possible values: DEBUG, INFO, WARN, ERROR
	Level string
}

// User is the type used to represents a system user.
type User struct {
	// The UUID of the underlying or referenced entity.
	ID string `json:"id,omitempty"`
	// The UID of the underlying or referenced entity in DGraph.
	UID *string `json:"uid,omitempty"`
	// The UUID of the underlying or referenced entity in the document database.
	Key *string `json:"_key,omitempty"`
	// The date/time the record was created.
	CreatedAt *string `json:"createdAt,omitempty"`
	// The date/time the record was last updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Defines if the entity is active.
	Active bool `json:"active"`
	// The first name of the user.
	FirstName string `json:"firstName,omitempty"`
	// The last name of the user.
	LastName string `json:"lastName,omitempty" storm:"index"`
	// The birth name of the user.
	BirthName string `json:"birthName,omitempty"`
	// The address of the user.
	Address *string `json:"address,omitempty"`
	// The id of the city.
	CityID *string `json:"cityId,omitempty"`
	// The ISO 3166-1 code of the country.
	CountryID *string `json:"countryId,omitempty"`
	// The latitude of the user's address.
	Latitude *float64 `json:"latitude,omitempty"`
	// The longitude of the user's address.
	Longitude *float64 `json:"longitude,omitempty"`
	// The birth date of the user.
	BirthDate *string `json:"birthDate,omitempty"`
	// The gender of the user.
	Gender *string `json:"gender,omitempty"`
	// The ISO code of the user's prefered language.
	LanguageID *string `json:"languageId,omitempty"`
	// The email of the user.
	Email string `json:"email,omitempty"`
	// The login of the user.
	Login string `json:"login,omitempty"`
	// The encrypted password of the user.
	EncryptedPassword string `json:"encryptedPassword,omitempty"`
	// The date/time the password will expire.
	PasswordExpiresAt *string `json:"passwordExpiresAt,omitempty"`
	// The date/time the email was validated.
	EmailValidatedAt *string `json:"emailValidatedAt,omitempty"`
	// The date/time the user is suspended up to.
	SuspendedUpTo *string `json:"suspendedUpTo,omitempty"`
	// The number of failed authentication attempts.
	FailedAttempts *int `json:"fialedAttempts,omitempty"`
	// The user mobile phone number.
	Mobile *string `json:"mobile,omitempty"`
	// Defines if this user is a B2C user.
	B2C bool `json:"b2c,omitempty"`
	// The id of organization where the user was created.
	OrganizationID string `json:"organizationId,omitempty"`
	// The list of the user roles.
	Roles []string `json:"roles,omitempty"`
}

// SAMLConfig is the type used to represents a SAML configuration.
type SAMLConfig struct {
	// The UUID of the underlying or referenced entity.
	ID string `json:"id,omitempty"`
	// The id of entity in the document database.
	Key *string `json:"_key,omitempty"`
	// The date/time the record was created.
	CreatedAt *string `json:"createdAt,omitempty"`
	// The date/time the record was last updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Defines if the entity is active.
	Active bool `json:"active,omitempty"`
	// The id of the associated organization.
	OrganizationID string `json:"organizationId,omitempty"`
	// The id of the associated area.
	AreaID string `json:"areaId,omitempty"`
	// The associated host/domain.
	Host string `json:"host,omitempty"`
	// The associated IDP metadata in XML.
	IdpMetadata string `json:"idpMetadata"`
	// The key used to manage the user identification.
	IDKey string `json:"idKey"`
	// The URL to be called back by the IDP.
	CallbackURL string `json:"callbackURL"`
	// The URL the service redirects to once the user is authenticated.
	RedirectURL string `json:"redirectURL"`
}

// Token is the type used to represents a JWT token.
type Token struct {
	// The UUID of the token.
	ID string `json:"id,omitempty"`
	// The id of entity in the document database.
	Key *string `json:"_key,omitempty"`
	// The type of the token.
	Type int `json:"type,omitempty"`
	// The UUID of the associated user.
	UserID string `json:"userId,omitempty"`
	// The id of the associated organization.
	OrganizationID string `json:"organizationId,omitempty"`
	// The id of the associated area.
	AreaID string `json:"areaId,omitempty"`
	// The value of the token.
	Token string `json:"token" storm:"index"`
	// The date/time the record was created.
	CreatedAt *string `json:"createdAt,omitempty"`
	// The date/time the token will expire.
	ExpiresAt *string `json:"expiresAt,omitempty"`
}

// AuthFailure is the type used to describe a failed authentication.
type AuthFailure struct {
	// The login used for the authentication.
	Login string
	// The id of the associated organization.
	OrganizationID string `json:"organizationId,omitempty"`
	// The id of the associated area.
	AreaID string `json:"areaId,omitempty"`
	// The date/time the record was created.
	CreatedAt string
}

// Password is the type used to represent a password.
type Password struct {
	// The UUID of the password.
	ID string `json:"id,omitempty"`
	// The UUID of the associated user.
	UserID string `json:"userId,omitempty"`
	// The encrypted password value.
	EncryptedPassword string `json:"encryptedPassword,omitempty"`
	// The date/time the record was created.
	CreatedAt *string `json:"createdAt,omitempty"`
}

// ErrorInfo is the type used to represent an error.
type ErrorInfo struct {
	// The name of the service.
	Service string
	// The id of the service instance.
	InstanceID string
	// The error message.
	Message string
	// The details about the error.
	Details *string
}

// ServiceStatusInfo is the type used to hold the service status information.
type ServiceStatusInfo struct {
	// The name of the service
	Service string
	// The id of the service instance
	InstanceID string
	// The new status of the service. Possible values: Initializing, Connecting,
	// Pending, Syncing, OK
	Status string
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "not_found",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadArgument builds a goa.ServiceError from an error.
func MakeBadArgument(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad_argument",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeNotAuthorized builds a goa.ServiceError from an error.
func MakeNotAuthorized(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "not_authorized",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeUnexpectedError builds a goa.ServiceError from an error.
func MakeUnexpectedError(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unexpected_error",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeInvalidScope builds a goa.ServiceError from an error.
func MakeInvalidScope(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "invalid_scope",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeTokenInvalid builds a goa.ServiceError from an error.
func MakeTokenInvalid(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "token_invalid",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeTokenExpired builds a goa.ServiceError from an error.
func MakeTokenExpired(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "token_expired",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakePasswordExpired builds a goa.ServiceError from an error.
func MakePasswordExpired(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "password_expired",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeInvalidCredentials builds a goa.ServiceError from an error.
func MakeInvalidCredentials(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "invalid_credentials",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeLoginBlocked builds a goa.ServiceError from an error.
func MakeLoginBlocked(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "login_blocked",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// NewSessionCollection initializes result type SessionCollection from viewed
// result type SessionCollection.
func NewSessionCollection(vres userqueryviews.SessionCollection) SessionCollection {
	var res SessionCollection
	switch vres.View {
	case "default", "":
		res = newSessionCollection(vres.Projected)
	case "tiny":
		res = newSessionCollectionTiny(vres.Projected)
	}
	return res
}

// NewViewedSessionCollection initializes viewed result type SessionCollection
// from result type SessionCollection using the given view.
func NewViewedSessionCollection(res SessionCollection, view string) userqueryviews.SessionCollection {
	var vres userqueryviews.SessionCollection
	switch view {
	case "default", "":
		p := newSessionCollectionView(res)
		vres = userqueryviews.SessionCollection{Projected: p, View: "default"}
	case "tiny":
		p := newSessionCollectionViewTiny(res)
		vres = userqueryviews.SessionCollection{Projected: p, View: "tiny"}
	}
	return vres
}

// NewRegisteredUserCollection initializes result type RegisteredUserCollection
// from viewed result type RegisteredUserCollection.
func NewRegisteredUserCollection(vres userqueryviews.RegisteredUserCollection) RegisteredUserCollection {
	var res RegisteredUserCollection
	switch vres.View {
	case "default", "":
		res = newRegisteredUserCollection(vres.Projected)
	case "tiny":
		res = newRegisteredUserCollectionTiny(vres.Projected)
	}
	return res
}

// NewViewedRegisteredUserCollection initializes viewed result type
// RegisteredUserCollection from result type RegisteredUserCollection using the
// given view.
func NewViewedRegisteredUserCollection(res RegisteredUserCollection, view string) userqueryviews.RegisteredUserCollection {
	var vres userqueryviews.RegisteredUserCollection
	switch view {
	case "default", "":
		p := newRegisteredUserCollectionView(res)
		vres = userqueryviews.RegisteredUserCollection{Projected: p, View: "default"}
	case "tiny":
		p := newRegisteredUserCollectionViewTiny(res)
		vres = userqueryviews.RegisteredUserCollection{Projected: p, View: "tiny"}
	}
	return vres
}

// newSessionCollection converts projected type SessionCollection to service
// type SessionCollection.
func newSessionCollection(vres userqueryviews.SessionCollectionView) SessionCollection {
	res := make(SessionCollection, len(vres))
	for i, n := range vres {
		res[i] = newSession(n)
	}
	return res
}

// newSessionCollectionTiny converts projected type SessionCollection to
// service type SessionCollection.
func newSessionCollectionTiny(vres userqueryviews.SessionCollectionView) SessionCollection {
	res := make(SessionCollection, len(vres))
	for i, n := range vres {
		res[i] = newSessionTiny(n)
	}
	return res
}

// newSessionCollectionView projects result type SessionCollection to projected
// type SessionCollectionView using the "default" view.
func newSessionCollectionView(res SessionCollection) userqueryviews.SessionCollectionView {
	vres := make(userqueryviews.SessionCollectionView, len(res))
	for i, n := range res {
		vres[i] = newSessionView(n)
	}
	return vres
}

// newSessionCollectionViewTiny projects result type SessionCollection to
// projected type SessionCollectionView using the "tiny" view.
func newSessionCollectionViewTiny(res SessionCollection) userqueryviews.SessionCollectionView {
	vres := make(userqueryviews.SessionCollectionView, len(res))
	for i, n := range res {
		vres[i] = newSessionViewTiny(n)
	}
	return vres
}

// newSession converts projected type Session to service type Session.
func newSession(vres *userqueryviews.SessionView) *Session {
	res := &Session{
		Key:       vres.Key,
		CreatedAt: vres.CreatedAt,
		UpdatedAt: vres.UpdatedAt,
		ExpiresAt: vres.ExpiresAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.OrganizationID != nil {
		res.OrganizationID = *vres.OrganizationID
	}
	if vres.AreaID != nil {
		res.AreaID = *vres.AreaID
	}
	if vres.UserID != nil {
		res.UserID = *vres.UserID
	}
	if vres.TokenID != nil {
		res.TokenID = *vres.TokenID
	}
	return res
}

// newSessionTiny converts projected type Session to service type Session.
func newSessionTiny(vres *userqueryviews.SessionView) *Session {
	res := &Session{
		CreatedAt: vres.CreatedAt,
		UpdatedAt: vres.UpdatedAt,
		ExpiresAt: vres.ExpiresAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.UserID != nil {
		res.UserID = *vres.UserID
	}
	return res
}

// newSessionView projects result type Session to projected type SessionView
// using the "default" view.
func newSessionView(res *Session) *userqueryviews.SessionView {
	vres := &userqueryviews.SessionView{
		ID:             &res.ID,
		Key:            res.Key,
		OrganizationID: &res.OrganizationID,
		AreaID:         &res.AreaID,
		UserID:         &res.UserID,
		TokenID:        &res.TokenID,
		CreatedAt:      res.CreatedAt,
		UpdatedAt:      res.UpdatedAt,
		ExpiresAt:      res.ExpiresAt,
	}
	return vres
}

// newSessionViewTiny projects result type Session to projected type
// SessionView using the "tiny" view.
func newSessionViewTiny(res *Session) *userqueryviews.SessionView {
	vres := &userqueryviews.SessionView{
		ID:        &res.ID,
		UserID:    &res.UserID,
		CreatedAt: res.CreatedAt,
		UpdatedAt: res.UpdatedAt,
		ExpiresAt: res.ExpiresAt,
	}
	return vres
}

// newRegisteredUserCollection converts projected type RegisteredUserCollection
// to service type RegisteredUserCollection.
func newRegisteredUserCollection(vres userqueryviews.RegisteredUserCollectionView) RegisteredUserCollection {
	res := make(RegisteredUserCollection, len(vres))
	for i, n := range vres {
		res[i] = newRegisteredUser(n)
	}
	return res
}

// newRegisteredUserCollectionTiny converts projected type
// RegisteredUserCollection to service type RegisteredUserCollection.
func newRegisteredUserCollectionTiny(vres userqueryviews.RegisteredUserCollectionView) RegisteredUserCollection {
	res := make(RegisteredUserCollection, len(vres))
	for i, n := range vres {
		res[i] = newRegisteredUserTiny(n)
	}
	return res
}

// newRegisteredUserCollectionView projects result type
// RegisteredUserCollection to projected type RegisteredUserCollectionView
// using the "default" view.
func newRegisteredUserCollectionView(res RegisteredUserCollection) userqueryviews.RegisteredUserCollectionView {
	vres := make(userqueryviews.RegisteredUserCollectionView, len(res))
	for i, n := range res {
		vres[i] = newRegisteredUserView(n)
	}
	return vres
}

// newRegisteredUserCollectionViewTiny projects result type
// RegisteredUserCollection to projected type RegisteredUserCollectionView
// using the "tiny" view.
func newRegisteredUserCollectionViewTiny(res RegisteredUserCollection) userqueryviews.RegisteredUserCollectionView {
	vres := make(userqueryviews.RegisteredUserCollectionView, len(res))
	for i, n := range res {
		vres[i] = newRegisteredUserViewTiny(n)
	}
	return vres
}

// newRegisteredUser converts projected type RegisteredUser to service type
// RegisteredUser.
func newRegisteredUser(vres *userqueryviews.RegisteredUserView) *RegisteredUser {
	res := &RegisteredUser{
		Address:    vres.Address,
		CityID:     vres.CityID,
		CountryID:  vres.CountryID,
		Latitude:   vres.Latitude,
		Longitude:  vres.Longitude,
		BirthDate:  vres.BirthDate,
		Gender:     vres.Gender,
		LanguageID: vres.LanguageID,
		Mobile:     vres.Mobile,
		CreatedAt:  vres.CreatedAt,
		UpdatedAt:  vres.UpdatedAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.FirstName != nil {
		res.FirstName = *vres.FirstName
	}
	if vres.LastName != nil {
		res.LastName = *vres.LastName
	}
	if vres.Active != nil {
		res.Active = *vres.Active
	}
	if vres.BirthName != nil {
		res.BirthName = *vres.BirthName
	}
	if vres.Email != nil {
		res.Email = *vres.Email
	}
	if vres.Login != nil {
		res.Login = *vres.Login
	}
	if vres.B2C != nil {
		res.B2C = *vres.B2C
	}
	if vres.OrganizationID != nil {
		res.OrganizationID = *vres.OrganizationID
	}
	if vres.Active == nil {
		res.Active = true
	}
	if vres.B2C == nil {
		res.B2C = false
	}
	if vres.Roles != nil {
		res.Roles = make([]string, len(vres.Roles))
		for i, val := range vres.Roles {
			res.Roles[i] = val
		}
	}
	return res
}

// newRegisteredUserTiny converts projected type RegisteredUser to service type
// RegisteredUser.
func newRegisteredUserTiny(vres *userqueryviews.RegisteredUserView) *RegisteredUser {
	res := &RegisteredUser{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.FirstName != nil {
		res.FirstName = *vres.FirstName
	}
	if vres.LastName != nil {
		res.LastName = *vres.LastName
	}
	if vres.Active != nil {
		res.Active = *vres.Active
	}
	if vres.Email != nil {
		res.Email = *vres.Email
	}
	if vres.Login != nil {
		res.Login = *vres.Login
	}
	if vres.OrganizationID != nil {
		res.OrganizationID = *vres.OrganizationID
	}
	if vres.Active == nil {
		res.Active = true
	}
	if vres.Roles != nil {
		res.Roles = make([]string, len(vres.Roles))
		for i, val := range vres.Roles {
			res.Roles[i] = val
		}
	}
	return res
}

// newRegisteredUserView projects result type RegisteredUser to projected type
// RegisteredUserView using the "default" view.
func newRegisteredUserView(res *RegisteredUser) *userqueryviews.RegisteredUserView {
	vres := &userqueryviews.RegisteredUserView{
		ID:             &res.ID,
		FirstName:      &res.FirstName,
		LastName:       &res.LastName,
		Active:         &res.Active,
		BirthName:      &res.BirthName,
		Address:        res.Address,
		CityID:         res.CityID,
		CountryID:      res.CountryID,
		Latitude:       res.Latitude,
		Longitude:      res.Longitude,
		BirthDate:      res.BirthDate,
		Gender:         res.Gender,
		LanguageID:     res.LanguageID,
		Email:          &res.Email,
		Login:          &res.Login,
		Mobile:         res.Mobile,
		B2C:            &res.B2C,
		CreatedAt:      res.CreatedAt,
		UpdatedAt:      res.UpdatedAt,
		OrganizationID: &res.OrganizationID,
	}
	if res.Roles != nil {
		vres.Roles = make([]string, len(res.Roles))
		for i, val := range res.Roles {
			vres.Roles[i] = val
		}
	}
	return vres
}

// newRegisteredUserViewTiny projects result type RegisteredUser to projected
// type RegisteredUserView using the "tiny" view.
func newRegisteredUserViewTiny(res *RegisteredUser) *userqueryviews.RegisteredUserView {
	vres := &userqueryviews.RegisteredUserView{
		ID:             &res.ID,
		FirstName:      &res.FirstName,
		LastName:       &res.LastName,
		Active:         &res.Active,
		Email:          &res.Email,
		Login:          &res.Login,
		OrganizationID: &res.OrganizationID,
	}
	if res.Roles != nil {
		vres.Roles = make([]string, len(res.Roles))
		for i, val := range res.Roles {
			vres.Roles[i] = val
		}
	}
	return vres
}
