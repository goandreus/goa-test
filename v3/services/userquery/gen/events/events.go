// Code generated by goa v3.0.9, DO NOT EDIT.
//
// Service Events
//
// Command:
// $ goa gen gitlab.com/wiserskills/v3/services/userquery/design

package events

import (
	"context"
	stdjson "encoding/json"
	"fmt"
	"os"
	"reflect"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/gofrs/uuid"
	jsoniter "github.com/json-iterator/go"
	"gitlab.com/wiserskills/v3/services/userquery/gen/constants"
	goamiddleware "goa.design/goa/v3/middleware"
)

var eventSubscriptions *subscriptionMap
var instanceId string
var expectedReplies map[string]string

func init() {

	eventSubscriptions = newSubscriptionMap()
	expectedReplies = make(map[string]string)

	// We generate a unique id that will be used for data synchronization
	newId, _ := newUUID()
	instanceId = newId
}

func GetInstanceID() string {
	return instanceId
}

// subscriptionMap contains all the subscriptions for a specified topic
type subscriptionMap struct {
	rm      *sync.RWMutex
	data    map[string]map[string]map[string]*EventSubscription
	options map[string]*TopicOptions
}

func newSubscriptionMap() *subscriptionMap {
	return &subscriptionMap{rm: &sync.RWMutex{}, data: make(map[string]map[string]map[string]*EventSubscription), options: make(map[string]*TopicOptions)}
}

// GetOptions returns the options for the specified topic
func (m *subscriptionMap) GetOptions(topic string) *TopicOptions {

	var result *TopicOptions

	m.rm.RLock()
	result = m.options[topic]
	m.rm.RUnlock()

	return result
}

func (m *subscriptionMap) SetOptions(topic string, options *TopicOptions) {

	m.rm.Lock()
	m.options[topic] = options
	m.rm.Unlock()
}

// GetByTopic returns the event subscriptions for the specified topic
func (m *subscriptionMap) GetByTopic(topic string) map[string]map[string]*EventSubscription {

	var result map[string]map[string]*EventSubscription

	m.rm.RLock()
	result = m.data[topic]
	m.rm.RUnlock()

	return result
}

// GetByEventName returns the event subscriptions for the specified topic and event name
func (m *subscriptionMap) GetByEventName(topic string, eventName string) map[string]*EventSubscription {

	var result map[string]*EventSubscription

	m.rm.RLock()
	if m.data[topic] != nil {
		result = m.data[topic][eventName]
	}
	m.rm.RUnlock()

	return result
}

func (m *subscriptionMap) Set(topic string, eventName string, sub *EventSubscription) {

	t := m.GetByTopic(topic)

	if t == nil {
		m.rm.Lock()
		m.data[topic] = make(map[string]map[string]*EventSubscription)
		m.data[topic][eventName] = make(map[string]*EventSubscription)
		t = m.data[topic]
		m.rm.Unlock()
	}

	if t[eventName] == nil {
		m.rm.Lock()
		t[eventName] = make(map[string]*EventSubscription)
		m.rm.Unlock()
	}

	m.rm.Lock()
	t[eventName][sub.ID] = sub
	m.rm.Unlock()
}

func (m *subscriptionMap) Topics() []string {

	result := []string{}

	for k, _ := range m.data {
		result = append(result, k)
	}

	return result
}

// EndpointInfo represents an endppoint of the service
type EndpointInfo struct {
	Name        string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Code        string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	Description string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	Verb        string `form:"verb,omitempty" json:"verb,omitempty" xml:"verb,omitempty"`
	Path        string `form:"path,omitempty" json:"path,omitempty" xml:"path,omitempty"`
	Service     string `form:"service,omitempty" json:"service,omitempty" xml:"service,omitempty"`
	Namespace   string `form:"namespace,omitempty" json:"namespace,omitempty" xml:"namespace,omitempty"`
}

// Event is the base type for events
type Event struct {
	ID           string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	UserID       string `form:"userId,omitempty" json:"userId,omitempty" xml:"userId,omitempty"`
	OrgID        string `form:"orgId,omitempty" json:"orgId,omitempty" xml:"orgId,omitempty"`
	SessionID    string `form:"sessionId,omitempty" json:"sessionId,omitempty" xml:"sessionId,omitempty"`
	Name         string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Timestamp    string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
	RequestID    string `form:"requestId,omitempty" json:"requestId,omitempty" xml:"requestId,omitempty"`
	RaisedBy     string `form:"raisedBy,omitempty" json:"raisedBy,omitempty" xml:"raisedBy,omitempty"`
	Action       int    `form:"action,omitempty" json:"action,omitempty" xml:"action,omitempty"`
	InResponseTo string `form:"inResponseTo,omitempty" json:"inResponseTo,omitempty" xml:"inResponseTo,omitempty"`
	AreaID       string `form:"areaId,omitempty" json:"areaId,omitempty" xml:"areaId,omitempty"`
	Typename     string `form:"typename,omitempty" json:"typename,omitempty" xml:"typename,omitempty"`
	Payload      string `form:"payload,omitempty" json:"payload,omitempty" xml:"payload,omitempty"`
}

// TopicHandler is the signature of the event bus client function executed when an event is received
type TopicHandler func(string, []byte) error

// EventHandler is the signature of the service function executed when an event is received
type EventHandler func(*Event, interface{}) error

type EventSubscription struct {
	ID       string
	Name     string
	Typename string
	Type     interface{}
	Handler  EventHandler
}

// TopicSubscription represents a topic subscription
type TopicSubscription struct {
	Topic         string
	Subscriptions map[string]map[string]*EventSubscription
	Options       *TopicOptions
	Handler       TopicHandler
	Registered    bool
}

// TopicOptions represents options for a specific topic
type TopicOptions struct {
	OnlyOnce        bool
	GroupName       string
	Durable         bool
	Replay          int
	ReplayParameter interface{}
	Registered      bool
}

// EventErrorHandler is the handler called in case of error
type EventSuccessHandler func(guid string)

// EventErrorHandler is the handler called in case of error
type EventErrorHandler func(guid string, err error)

// EventbusClient is the interface used to manage a connection with an event bus
type EventbusClient interface {
	Connect() error
	SetDefaultTopic(string)
	SetWriteTimeout(time.Duration)
	Close() error
	Write([]byte) (int, error)
	WriteWithTopic(string, []byte, bool, EventSuccessHandler, EventErrorHandler) error
	Reload([]*TopicSubscription) error
}

// PublishEvent sends an event to the event bus
func PublishEvent(bus EventbusClient, topics string, e *Event, payload interface{}, async bool) (error, string) {

	allTopics := strings.Split(topics, ";")
	parsedTopics := ""

	for _, topic := range allTopics {

		t := ParseTopic(topic, e, payload)

		if bus != nil {
			var json = jsoniter.ConfigCompatibleWithStandardLibrary
			bytes, err := json.Marshal(e)
			if err != nil {
				return err, t
			}

			success := func(guid string) {
				CheckIfHasExpectedReply(e)
			}

			failure := func(guid string, err error) {
			}

			err = bus.WriteWithTopic(t, bytes, async, success, failure)
			if err != nil {
				return err, t
			}

			if parsedTopics != "" {
				parsedTopics = parsedTopics + ";" + t
			} else {
				parsedTopics = t
			}
		}
	}

	return nil, parsedTopics
}

// getUserId gets the userId from the context.
func getUserId(ctx context.Context) string {
	result := ""
	result, _ = ctx.Value(constants.ContextKeyUserID).(string)
	return result
}

// getSessionId gets the sessionId from the context.
func getSessionId(ctx context.Context) string {
	result := ""
	result, _ = ctx.Value(constants.ContextKeySessionID).(string)
	return result
}

// Creates a context from event information
func CreateContextFromEvent(e *Event) context.Context {

	ctx := context.Background()

	ctx = context.WithValue(ctx, goamiddleware.RequestIDKey, e.RequestID)
	ctx = context.WithValue(ctx, constants.ContextKeyUserID, e.UserID)
	ctx = context.WithValue(ctx, constants.ContextKeySessionID, e.SessionID)
	ctx = context.WithValue(ctx, constants.ContextKeyOrgID, e.OrgID)
	ctx = context.WithValue(ctx, constants.ContextKeyAreaID, e.AreaID)

	return ctx
}

// Creates a new event
func NewEvent(ctx context.Context, name string, action int, typeName string, payload interface{}) (*Event, error) {

	id, _ := newUUID()
	t := time.Now().UTC()
	timestamp := t.Format(time.RFC3339Nano)
	requestId, _ := ctx.Value(goamiddleware.RequestIDKey).(string)
	orgId, _ := ctx.Value(constants.ContextKeyOrgID).(string)
	areaId, _ := ctx.Value(constants.ContextKeyAreaID).(string)
	raisedBy := instanceId
	userId := getUserId(ctx)
	sessionId := getSessionId(ctx)

	typename := ""
	p := ""

	if payload != nil {

		typename = reflect.TypeOf(payload).String()

		if typename == "string" {
			p = payload.(string)
		} else {
			tv := reflect.ValueOf(payload).Elem()
			typename = strings.Replace(tv.Type().Name(), "userquery.", "", -1)
			var json = jsoniter.ConfigCompatibleWithStandardLibrary
			j, err := json.Marshal(payload)

			if err != nil {
				return nil, err
			}

			p = string(j)
		}
	}

	if typeName != "" && typeName != typename {
		typename = typeName
	}

	e := Event{
		ID:        id,
		UserID:    userId,
		OrgID:     orgId,
		SessionID: sessionId,
		Name:      name,
		Timestamp: timestamp,
		RequestID: requestId,
		Action:    action,
		RaisedBy:  raisedBy,
		AreaID:    areaId,
		Typename:  typename,
		Payload:   p,
	}

	return &e, nil
}

// RegisterTopicOptions registers options for the specified topic
func RegisterTopicOptions(topic string, onlyOnce bool, groupName string, durable bool, replayOption int, replayParameter interface{}) {

	options := TopicOptions{
		OnlyOnce:        onlyOnce,
		GroupName:       groupName,
		Durable:         durable,
		Replay:          replayOption,
		ReplayParameter: replayParameter,
	}

	if strings.Contains(topic, "[EVENT_INSTANCE_ID]") {
		options.Durable = false
	}

	eventSubscriptions.SetOptions(topic, &options)
}

// RegisterEventHandler registers an event handler
func RegisterEventHandler(topic string, name string, handler EventHandler, payloadType interface{}) {

	typename := ""

	if payloadType != nil {
		typename = reflect.TypeOf(payloadType).Name()
	}

	id, _ := newUUID()

	sub := EventSubscription{
		ID:       id,
		Name:     name,
		Typename: typename,
		Type:     payloadType,
		Handler:  handler,
	}

	tp := ParseTopic(topic, nil, nil)

	eventSubscriptions.Set(tp, name, &sub)
}

// GetTopicSubscriptions returns the subscription for the specifed topic
func GetTopicSubscriptions() []*TopicSubscription {

	result := []*TopicSubscription{}

	for _, topic := range eventSubscriptions.Topics() {

		handler := func(topic string, data []byte) error {
			jsonBlob := []byte(string(data))
			var evt Event
			var json = jsoniter.ConfigCompatibleWithStandardLibrary
			err := json.Unmarshal(jsonBlob, &evt)
			if err == nil {
				subscriptions := eventSubscriptions.GetByEventName(topic, evt.Name)
				if len(subscriptions) > 0 {
					for _, evtsub := range subscriptions {
						t := reflect.ValueOf(evtsub.Type)
						if t.IsValid() {
							name := t.Type().Name()
							if name == "string" {
								return evtsub.Handler(&evt, evt.Payload)
							} else {
								p := reflect.New(t.Type()).Interface()
								if evt.Payload != "" {
									err = json.Unmarshal([]byte(evt.Payload), p)
									if err == nil {
										return evtsub.Handler(&evt, p)
									} else {
										return err
									}
								} else {
									return evtsub.Handler(&evt, nil)
								}
							}
						} else {

							var objmap map[string]*stdjson.RawMessage
							err := stdjson.Unmarshal(data, &objmap)

							if err == nil {
								return evtsub.Handler(&evt, objmap)
							} else {
								return evtsub.Handler(&evt, nil)
							}
						}
					}
				} else {
					fmt.Println("No subscription for: " + evt.Name)
					return nil
				}
			} else {
				return err
			}

			return nil
		}

		parsedTopic := ParseTopic(topic, nil, nil)

		options := eventSubscriptions.GetOptions(topic)

		sub := TopicSubscription{
			Topic:   parsedTopic,
			Handler: handler,
			Options: options,
		}

		result = append(result, &sub)
	}

	return result
}

// contains determines if a string is part of string array
func contains(slice []string, item string) bool {

	set := make(map[string]struct{}, len(slice))
	for _, s := range slice {
		set[s] = struct{}{}
	}

	_, ok := set[item]
	return ok
}

// ParseTopic formats the passed topic pattern
func ParseTopic(topicPattern string, e *Event, payload interface{}) string {
	r := regexp.MustCompile(`\[(.*?)\]`)
	res := r.FindAllStringSubmatch(topicPattern, -1)
	result := topicPattern
	for i := range res {
		t := res[i][0]
		g := res[i][1]

		if payload != nil && strings.Contains(g, "$Payload") {

			var p interface{}
			p = payload
			components := strings.Split(g, ".")
			for _, component := range components {
				if component == "$Payload" {
					continue
				}

				p = reflectField(p, component)
			}

			ps := fmt.Sprintf("%v", p)

			result = strings.Replace(result, t, ps, -1)
		}

		if e != nil && strings.Contains(g, "$Event") {

			var p interface{}
			p = e
			components := strings.Split(g, ".")
			for _, component := range components {
				if component == "$Event" {
					continue
				}

				p = reflectField(p, component)
			}

			ps := fmt.Sprintf("%v", p)

			result = strings.Replace(result, t, ps, -1)
		}

		if g != "EVENT_INSTANCE_ID" {
			if v, ok := os.LookupEnv(g); ok {
				result = strings.Replace(result, t, v, -1)
			}
		} else {
			result = strings.Replace(result, t, instanceId, -1)
		}
	}

	return strings.ToLower(result)
}

// ReflectField returns the value of the specified field by reflection
func reflectField(obj interface{}, field string) interface{} {

	if obj == nil {
		return nil
	}

	val := reflect.ValueOf(obj).Elem()

	f := val.FieldByName(field)

	if !f.IsValid() {
		return nil
	}

	if f.Kind() == reflect.Ptr {
		return f.Elem().Interface()
	} else {
		return f.Interface()
	}
}

// CheckIfHasExpectedReply checks if the passed event will expect a reply and if so stores its id in memory
func CheckIfHasExpectedReply(e *Event) {
	if e.Action == 6 {
		var glock sync.Mutex
		glock.Lock()
		expectedReplies[e.ID] = e.Timestamp
		glock.Unlock()
	}
}

// CheckIfIsExpectedReply checks if the passed event is an expected reply and if so remove the originated id from memory
func CheckIfIsExpectedReply(e *Event) {
	if e.Action == 7 && e.InResponseTo != "" {
		var glock sync.Mutex
		glock.Lock()
		delete(expectedReplies, e.InResponseTo)
		glock.Unlock()
	}
}

// CountExpectedReplies counts the number of expected replies
func CountExpectedReplies() int {
	return len(expectedReplies)
}

// newUUID creates a new unique universal identifier
func newUUID() (string, error) {

	result, err := uuid.NewV4()

	if err != nil {
		return "", err
	}

	return result.String(), nil
}

// getEnv returns the environment variable for the passed key or the specified default value
func getEnv(key string, defaultValue string) string {

	if value, ok := os.LookupEnv(key); ok {
		return value
	}

	return defaultValue
}
