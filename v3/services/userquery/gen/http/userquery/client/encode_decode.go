// Code generated by goa v3.0.9, DO NOT EDIT.
//
// userquery HTTP client encoders and decoders
//
// Command:
// $ goa gen gitlab.com/wiserskills/v3/services/userquery/design

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"

	userquery "gitlab.com/wiserskills/v3/services/userquery/gen/userquery"
	userqueryviews "gitlab.com/wiserskills/v3/services/userquery/gen/userquery/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildSignInRequest instantiates a HTTP request object with method and path
// set to call the "userquery" service "SignIn" endpoint
func (c *Client) BuildSignInRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SignInUserqueryPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "SignIn", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSignInRequest returns an encoder for requests sent to the userquery
// SignIn server.
func EncodeSignInRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userquery.SignInPayload)
		if !ok {
			return goahttp.ErrInvalidType("userquery", "SignIn", "*userquery.SignInPayload", v)
		}
		if p.Key != nil {
			req.Header.Set("X-API-KEY", *p.Key)
		}
		req.Header.Set("X-ORG-ID", p.OrgID)
		req.Header.Set("X-AREA-ID", p.AreaID)
		req.SetBasicAuth(p.Username, p.Password)
		return nil
	}
}

// DecodeSignInResponse returns a decoder for responses returned by the
// userquery SignIn endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeSignInResponse may return the following errors:
//	- "bad_argument" (type *goa.ServiceError): http.StatusBadRequest
//	- "not_authorized" (type *goa.ServiceError): http.StatusForbidden
//	- "invalid_credentials" (type *goa.ServiceError): http.StatusForbidden
//	- "password_expired" (type *goa.ServiceError): http.StatusForbidden
//	- "login_blocked" (type *goa.ServiceError): http.StatusForbidden
//	- "unexpected_error" (type *goa.ServiceError): http.StatusInternalServerError
//	- error: internal error
func DecodeSignInResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body SignInResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "SignIn", err)
			}
			err = ValidateSignInResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SignIn", err)
			}
			res := NewSignInJWTTokenOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body SignInBadArgumentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "SignIn", err)
			}
			err = ValidateSignInBadArgumentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SignIn", err)
			}
			return nil, NewSignInBadArgument(&body)
		case http.StatusForbidden:
			en := resp.Header.Get("goa-error")
			switch en {
			case "not_authorized":
				var (
					body SignInNotAuthorizedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "SignIn", err)
				}
				err = ValidateSignInNotAuthorizedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "SignIn", err)
				}
				return nil, NewSignInNotAuthorized(&body)
			case "invalid_credentials":
				var (
					body SignInInvalidCredentialsResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "SignIn", err)
				}
				err = ValidateSignInInvalidCredentialsResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "SignIn", err)
				}
				return nil, NewSignInInvalidCredentials(&body)
			case "password_expired":
				var (
					body SignInPasswordExpiredResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "SignIn", err)
				}
				err = ValidateSignInPasswordExpiredResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "SignIn", err)
				}
				return nil, NewSignInPasswordExpired(&body)
			case "login_blocked":
				var (
					body SignInLoginBlockedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "SignIn", err)
				}
				err = ValidateSignInLoginBlockedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "SignIn", err)
				}
				return nil, NewSignInLoginBlocked(&body)
			default:
				body, _ := ioutil.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("userquery", "SignIn", resp.StatusCode, string(body))
			}
		case http.StatusInternalServerError:
			var (
				body SignInUnexpectedErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "SignIn", err)
			}
			err = ValidateSignInUnexpectedErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SignIn", err)
			}
			return nil, NewSignInUnexpectedError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "SignIn", resp.StatusCode, string(body))
		}
	}
}

// BuildSignOutRequest instantiates a HTTP request object with method and path
// set to call the "userquery" service "SignOut" endpoint
func (c *Client) BuildSignOutRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SignOutUserqueryPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "SignOut", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSignOutRequest returns an encoder for requests sent to the userquery
// SignOut server.
func EncodeSignOutRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userquery.TokenPayload)
		if !ok {
			return goahttp.ErrInvalidType("userquery", "SignOut", "*userquery.TokenPayload", v)
		}
		req.Header.Set("Authorization", p.Token)
		req.Header.Set("X-API-KEY", p.Key)
		req.Header.Set("X-ORG-ID", p.OrgID)
		req.Header.Set("X-AREA-ID", p.AreaID)
		return nil
	}
}

// DecodeSignOutResponse returns a decoder for responses returned by the
// userquery SignOut endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeSignOutResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "token_expired" (type *goa.ServiceError): http.StatusForbidden
//	- "token_invalid" (type *goa.ServiceError): http.StatusForbidden
//	- "not_authorized" (type *goa.ServiceError): http.StatusForbidden
//	- "bad_argument" (type *goa.ServiceError): http.StatusBadRequest
//	- "unexpected_error" (type *goa.ServiceError): http.StatusInternalServerError
//	- error: internal error
func DecodeSignOutResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusNotFound:
			var (
				body SignOutNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "SignOut", err)
			}
			err = ValidateSignOutNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SignOut", err)
			}
			return nil, NewSignOutNotFound(&body)
		case http.StatusForbidden:
			en := resp.Header.Get("goa-error")
			switch en {
			case "token_expired":
				var (
					body SignOutTokenExpiredResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "SignOut", err)
				}
				err = ValidateSignOutTokenExpiredResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "SignOut", err)
				}
				return nil, NewSignOutTokenExpired(&body)
			case "token_invalid":
				var (
					body SignOutTokenInvalidResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "SignOut", err)
				}
				err = ValidateSignOutTokenInvalidResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "SignOut", err)
				}
				return nil, NewSignOutTokenInvalid(&body)
			case "not_authorized":
				var (
					body SignOutNotAuthorizedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "SignOut", err)
				}
				err = ValidateSignOutNotAuthorizedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "SignOut", err)
				}
				return nil, NewSignOutNotAuthorized(&body)
			default:
				body, _ := ioutil.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("userquery", "SignOut", resp.StatusCode, string(body))
			}
		case http.StatusBadRequest:
			var (
				body SignOutBadArgumentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "SignOut", err)
			}
			err = ValidateSignOutBadArgumentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SignOut", err)
			}
			return nil, NewSignOutBadArgument(&body)
		case http.StatusInternalServerError:
			var (
				body SignOutUnexpectedErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "SignOut", err)
			}
			err = ValidateSignOutUnexpectedErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SignOut", err)
			}
			return nil, NewSignOutUnexpectedError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "SignOut", resp.StatusCode, string(body))
		}
	}
}

// BuildGetAllSessionsRequest instantiates a HTTP request object with method
// and path set to call the "userquery" service "GetAllSessions" endpoint
func (c *Client) BuildGetAllSessionsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetAllSessionsUserqueryPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "GetAllSessions", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetAllSessionsRequest returns an encoder for requests sent to the
// userquery GetAllSessions server.
func EncodeGetAllSessionsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userquery.AllSessionsPayload)
		if !ok {
			return goahttp.ErrInvalidType("userquery", "GetAllSessions", "*userquery.AllSessionsPayload", v)
		}
		req.Header.Set("Authorization", p.Token)
		req.Header.Set("X-API-KEY", p.Key)
		req.Header.Set("X-ORG-ID", p.OrgID)
		req.Header.Set("X-AREA-ID", p.AreaID)
		values := req.URL.Query()
		if p.View != nil {
			values.Add("view", *p.View)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetAllSessionsResponse returns a decoder for responses returned by the
// userquery GetAllSessions endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeGetAllSessionsResponse may return the following errors:
//	- "token_expired" (type *goa.ServiceError): http.StatusForbidden
//	- "token_invalid" (type *goa.ServiceError): http.StatusForbidden
//	- "bad_argument" (type *goa.ServiceError): http.StatusBadRequest
//	- "unexpected_error" (type *goa.ServiceError): http.StatusInternalServerError
//	- error: internal error
func DecodeGetAllSessionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetAllSessionsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "GetAllSessions", err)
			}
			p := NewGetAllSessionsSessionCollectionOK(body)
			view := resp.Header.Get("goa-view")
			vres := userqueryviews.SessionCollection{Projected: p, View: view}
			if err = userqueryviews.ValidateSessionCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetAllSessions", err)
			}
			res := userquery.NewSessionCollection(vres)
			return res, nil
		case http.StatusForbidden:
			en := resp.Header.Get("goa-error")
			switch en {
			case "token_expired":
				var (
					body GetAllSessionsTokenExpiredResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "GetAllSessions", err)
				}
				err = ValidateGetAllSessionsTokenExpiredResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "GetAllSessions", err)
				}
				return nil, NewGetAllSessionsTokenExpired(&body)
			case "token_invalid":
				var (
					body GetAllSessionsTokenInvalidResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "GetAllSessions", err)
				}
				err = ValidateGetAllSessionsTokenInvalidResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "GetAllSessions", err)
				}
				return nil, NewGetAllSessionsTokenInvalid(&body)
			default:
				body, _ := ioutil.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("userquery", "GetAllSessions", resp.StatusCode, string(body))
			}
		case http.StatusBadRequest:
			var (
				body GetAllSessionsBadArgumentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "GetAllSessions", err)
			}
			err = ValidateGetAllSessionsBadArgumentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetAllSessions", err)
			}
			return nil, NewGetAllSessionsBadArgument(&body)
		case http.StatusInternalServerError:
			var (
				body GetAllSessionsUnexpectedErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "GetAllSessions", err)
			}
			err = ValidateGetAllSessionsUnexpectedErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetAllSessions", err)
			}
			return nil, NewGetAllSessionsUnexpectedError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "GetAllSessions", resp.StatusCode, string(body))
		}
	}
}

// BuildGetIDPURLRequest instantiates a HTTP request object with method and
// path set to call the "userquery" service "GetIDPURL" endpoint
func (c *Client) BuildGetIDPURLRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetIDPURLUserqueryPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "GetIDPURL", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetIDPURLRequest returns an encoder for requests sent to the userquery
// GetIDPURL server.
func EncodeGetIDPURLRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userquery.HostPayload)
		if !ok {
			return goahttp.ErrInvalidType("userquery", "GetIDPURL", "*userquery.HostPayload", v)
		}
		req.Header.Set("X-API-KEY", p.Key)
		req.Header.Set("X-ORG-ID", p.OrgID)
		req.Header.Set("X-AREA-ID", p.AreaID)
		req.Header.Set("Host", p.Host)
		return nil
	}
}

// DecodeGetIDPURLResponse returns a decoder for responses returned by the
// userquery GetIDPURL endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeGetIDPURLResponse may return the following errors:
//	- "bad_argument" (type *goa.ServiceError): http.StatusBadRequest
//	- "unexpected_error" (type *goa.ServiceError): http.StatusInternalServerError
//	- error: internal error
func DecodeGetIDPURLResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusPermanentRedirect:
			var (
				location string
				err      error
			)
			locationRaw := resp.Header.Get("Location")
			if locationRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("Location", "header"))
			}
			location = locationRaw
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetIDPURL", err)
			}
			res := NewGetIDPURLRedirectResultPermanentRedirect(location)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetIDPURLBadArgumentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "GetIDPURL", err)
			}
			err = ValidateGetIDPURLBadArgumentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetIDPURL", err)
			}
			return nil, NewGetIDPURLBadArgument(&body)
		case http.StatusInternalServerError:
			var (
				body GetIDPURLUnexpectedErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "GetIDPURL", err)
			}
			err = ValidateGetIDPURLUnexpectedErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetIDPURL", err)
			}
			return nil, NewGetIDPURLUnexpectedError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "GetIDPURL", resp.StatusCode, string(body))
		}
	}
}

// BuildSamlSignInRequest instantiates a HTTP request object with method and
// path set to call the "userquery" service "SamlSignIn" endpoint
func (c *Client) BuildSamlSignInRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SamlSignInUserqueryPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "SamlSignIn", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSamlSignInRequest returns an encoder for requests sent to the
// userquery SamlSignIn server.
func EncodeSamlSignInRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(string)
		if !ok {
			return goahttp.ErrInvalidType("userquery", "SamlSignIn", "string", v)
		}
		body := p
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("userquery", "SamlSignIn", err)
		}
		return nil
	}
}

// DecodeSamlSignInResponse returns a decoder for responses returned by the
// userquery SamlSignIn endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeSamlSignInResponse may return the following errors:
//	- "not_authorized" (type *goa.ServiceError): http.StatusForbidden
//	- "bad_argument" (type *goa.ServiceError): http.StatusBadRequest
//	- "unexpected_error" (type *goa.ServiceError): http.StatusInternalServerError
//	- error: internal error
func DecodeSamlSignInResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusPermanentRedirect:
			var (
				location string
				err      error
			)
			locationRaw := resp.Header.Get("Location")
			if locationRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("Location", "header"))
			}
			location = locationRaw
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SamlSignIn", err)
			}
			res := NewSamlSignInRedirectResultPermanentRedirect(location)
			return res, nil
		case http.StatusForbidden:
			var (
				body SamlSignInNotAuthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "SamlSignIn", err)
			}
			err = ValidateSamlSignInNotAuthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SamlSignIn", err)
			}
			return nil, NewSamlSignInNotAuthorized(&body)
		case http.StatusBadRequest:
			var (
				body SamlSignInBadArgumentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "SamlSignIn", err)
			}
			err = ValidateSamlSignInBadArgumentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SamlSignIn", err)
			}
			return nil, NewSamlSignInBadArgument(&body)
		case http.StatusInternalServerError:
			var (
				body SamlSignInUnexpectedErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "SamlSignIn", err)
			}
			err = ValidateSamlSignInUnexpectedErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "SamlSignIn", err)
			}
			return nil, NewSamlSignInUnexpectedError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "SamlSignIn", resp.StatusCode, string(body))
		}
	}
}

// BuildCheckTokenRequest instantiates a HTTP request object with method and
// path set to call the "userquery" service "CheckToken" endpoint
func (c *Client) BuildCheckTokenRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CheckTokenUserqueryPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "CheckToken", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCheckTokenRequest returns an encoder for requests sent to the
// userquery CheckToken server.
func EncodeCheckTokenRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userquery.TokenPayload)
		if !ok {
			return goahttp.ErrInvalidType("userquery", "CheckToken", "*userquery.TokenPayload", v)
		}
		req.Header.Set("Authorization", p.Token)
		req.Header.Set("X-API-KEY", p.Key)
		req.Header.Set("X-ORG-ID", p.OrgID)
		req.Header.Set("X-AREA-ID", p.AreaID)
		return nil
	}
}

// DecodeCheckTokenResponse returns a decoder for responses returned by the
// userquery CheckToken endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeCheckTokenResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "token_expired" (type *goa.ServiceError): http.StatusForbidden
//	- "token_invalid" (type *goa.ServiceError): http.StatusForbidden
//	- "not_authorized" (type *goa.ServiceError): http.StatusForbidden
//	- "bad_argument" (type *goa.ServiceError): http.StatusBadRequest
//	- "unexpected_error" (type *goa.ServiceError): http.StatusInternalServerError
//	- error: internal error
func DecodeCheckTokenResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusNotFound:
			var (
				body CheckTokenNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "CheckToken", err)
			}
			err = ValidateCheckTokenNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "CheckToken", err)
			}
			return nil, NewCheckTokenNotFound(&body)
		case http.StatusForbidden:
			en := resp.Header.Get("goa-error")
			switch en {
			case "token_expired":
				var (
					body CheckTokenTokenExpiredResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "CheckToken", err)
				}
				err = ValidateCheckTokenTokenExpiredResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "CheckToken", err)
				}
				return nil, NewCheckTokenTokenExpired(&body)
			case "token_invalid":
				var (
					body CheckTokenTokenInvalidResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "CheckToken", err)
				}
				err = ValidateCheckTokenTokenInvalidResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "CheckToken", err)
				}
				return nil, NewCheckTokenTokenInvalid(&body)
			case "not_authorized":
				var (
					body CheckTokenNotAuthorizedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "CheckToken", err)
				}
				err = ValidateCheckTokenNotAuthorizedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "CheckToken", err)
				}
				return nil, NewCheckTokenNotAuthorized(&body)
			default:
				body, _ := ioutil.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("userquery", "CheckToken", resp.StatusCode, string(body))
			}
		case http.StatusBadRequest:
			var (
				body CheckTokenBadArgumentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "CheckToken", err)
			}
			err = ValidateCheckTokenBadArgumentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "CheckToken", err)
			}
			return nil, NewCheckTokenBadArgument(&body)
		case http.StatusInternalServerError:
			var (
				body CheckTokenUnexpectedErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "CheckToken", err)
			}
			err = ValidateCheckTokenUnexpectedErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "CheckToken", err)
			}
			return nil, NewCheckTokenUnexpectedError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "CheckToken", resp.StatusCode, string(body))
		}
	}
}

// BuildGetUsersByIDRequest instantiates a HTTP request object with method and
// path set to call the "userquery" service "GetUsersByID" endpoint
func (c *Client) BuildGetUsersByIDRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetUsersByIDUserqueryPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "GetUsersByID", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetUsersByIDRequest returns an encoder for requests sent to the
// userquery GetUsersByID server.
func EncodeGetUsersByIDRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userquery.ManyUserIDPayload)
		if !ok {
			return goahttp.ErrInvalidType("userquery", "GetUsersByID", "*userquery.ManyUserIDPayload", v)
		}
		req.Header.Set("Authorization", p.Token)
		req.Header.Set("X-API-KEY", p.Key)
		req.Header.Set("X-ORG-ID", p.OrgID)
		req.Header.Set("X-AREA-ID", p.AreaID)
		values := req.URL.Query()
		values.Add("view", p.View)
		req.URL.RawQuery = values.Encode()
		body := p
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("userquery", "GetUsersByID", err)
		}
		return nil
	}
}

// DecodeGetUsersByIDResponse returns a decoder for responses returned by the
// userquery GetUsersByID endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeGetUsersByIDResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "token_expired" (type *goa.ServiceError): http.StatusForbidden
//	- "token_invalid" (type *goa.ServiceError): http.StatusForbidden
//	- "not_authorized" (type *goa.ServiceError): http.StatusForbidden
//	- "bad_argument" (type *goa.ServiceError): http.StatusBadRequest
//	- "unexpected_error" (type *goa.ServiceError): http.StatusInternalServerError
//	- error: internal error
func DecodeGetUsersByIDResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetUsersByIDResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "GetUsersByID", err)
			}
			p := NewGetUsersByIDRegisteredUserCollectionOK(body)
			view := resp.Header.Get("goa-view")
			vres := userqueryviews.RegisteredUserCollection{Projected: p, View: view}
			if err = userqueryviews.ValidateRegisteredUserCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetUsersByID", err)
			}
			res := userquery.NewRegisteredUserCollection(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetUsersByIDNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "GetUsersByID", err)
			}
			err = ValidateGetUsersByIDNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetUsersByID", err)
			}
			return nil, NewGetUsersByIDNotFound(&body)
		case http.StatusForbidden:
			en := resp.Header.Get("goa-error")
			switch en {
			case "token_expired":
				var (
					body GetUsersByIDTokenExpiredResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "GetUsersByID", err)
				}
				err = ValidateGetUsersByIDTokenExpiredResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "GetUsersByID", err)
				}
				return nil, NewGetUsersByIDTokenExpired(&body)
			case "token_invalid":
				var (
					body GetUsersByIDTokenInvalidResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "GetUsersByID", err)
				}
				err = ValidateGetUsersByIDTokenInvalidResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "GetUsersByID", err)
				}
				return nil, NewGetUsersByIDTokenInvalid(&body)
			case "not_authorized":
				var (
					body GetUsersByIDNotAuthorizedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("userquery", "GetUsersByID", err)
				}
				err = ValidateGetUsersByIDNotAuthorizedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("userquery", "GetUsersByID", err)
				}
				return nil, NewGetUsersByIDNotAuthorized(&body)
			default:
				body, _ := ioutil.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("userquery", "GetUsersByID", resp.StatusCode, string(body))
			}
		case http.StatusBadRequest:
			var (
				body GetUsersByIDBadArgumentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "GetUsersByID", err)
			}
			err = ValidateGetUsersByIDBadArgumentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetUsersByID", err)
			}
			return nil, NewGetUsersByIDBadArgument(&body)
		case http.StatusInternalServerError:
			var (
				body GetUsersByIDUnexpectedErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "GetUsersByID", err)
			}
			err = ValidateGetUsersByIDUnexpectedErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("userquery", "GetUsersByID", err)
			}
			return nil, NewGetUsersByIDUnexpectedError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "GetUsersByID", resp.StatusCode, string(body))
		}
	}
}

// BuildHealthRequest instantiates a HTTP request object with method and path
// set to call the "userquery" service "health" endpoint
func (c *Client) BuildHealthRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: HealthUserqueryPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "health", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeHealthResponse returns a decoder for responses returned by the
// userquery health endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeHealthResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body HealthResult
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "health", err)
			}
			res := NewHealthResultOK(&body)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "health", resp.StatusCode, string(body))
		}
	}
}

// BuildMetricsRequest instantiates a HTTP request object with method and path
// set to call the "userquery" service "metrics" endpoint
func (c *Client) BuildMetricsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: MetricsUserqueryPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "metrics", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeMetricsResponse returns a decoder for responses returned by the
// userquery metrics endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeMetricsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "metrics", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "metrics", resp.StatusCode, string(body))
		}
	}
}

// BuildSwaggerRequest instantiates a HTTP request object with method and path
// set to call the "userquery" service "swagger" endpoint
func (c *Client) BuildSwaggerRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SwaggerUserqueryPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "swagger", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeSwaggerResponse returns a decoder for responses returned by the
// userquery swagger endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeSwaggerResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "swagger", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "swagger", resp.StatusCode, string(body))
		}
	}
}

// BuildSwaggerUIRequest instantiates a HTTP request object with method and
// path set to call the "userquery" service "swagger-ui" endpoint
func (c *Client) BuildSwaggerUIRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SwaggerUIUserqueryPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("userquery", "swagger-ui", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeSwaggerUIResponse returns a decoder for responses returned by the
// userquery swagger-ui endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeSwaggerUIResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("userquery", "swagger-ui", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("userquery", "swagger-ui", resp.StatusCode, string(body))
		}
	}
}
